
;=============================================
; 第二章 寄存器 ==============================


1、数据寄存器
AX = AH + AL  16位寄存器，AX的高8位构成AH寄存器，AX的低8位构成AL寄存器   H = high, L = low
BX
CX
DX

0000 0000 ~ 1111 1111   0~ff  0~255
内存的最小单元是字节 8bit 1Byte
8086CPU 一次性可以处理2种尺寸的数据
有16根数据线，数据线的宽度决定了CPU一次性能够读取 多长的数据

字节型数据       byte 8bit - 8位寄存器
字型数据         2byte 16bit - 16位寄存器 2个字节
一个字节是字型数据的高位字节(AH,BH,CH,DH),一个字节是字型数据的低位字节(AL,BL,CL,DL)

2、在使用 mov 时，要保证 数据与寄存器之间 位数一致性
数据与寄存器之间要保证 一致性, 8位数据给8位寄存器，16位数据给16位寄存器

mov ax,93  
add al,85   ax=18
8位寄存器进行8位 运算，保存8位数据,溢出数据不会丢弃，保存到其他位置
16位寄存器进行16位 运算，保存16位数据,溢出数据不会丢弃，保存到其他位置
寄存器是互相独立的，AL就是AL，AH就是AH，不会互相影响


3、地址寄存器

段地址寄存器:偏移地址寄存器
DS              SP
ES              BP
SS              SI
CS              DI
                IP
                BX
8086CPU  16位寄存器 ，20根地址总线， 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111  0~FFFFFH
地址总线的数量决定了CPU的寻址能力
地址加法器，地址的计算方式
段地址 X 16(10H) + 偏移地址 = 物理地址
段地址 X 16(10H) = 基础地质
基础地质 + 偏移地址 = 物理地址

段地址       偏移地址     物理地址
F230H*10H +   C8H       = F23C8H 

8086CPU中 在任意时刻，将 CS(段地址):IP(偏移地址) 组合出来的地址，所指向的内存单元中的内容当作指令来执行
在8086CPU 加电启动或复位后，CS和IP被设置为CS=FFFFH,IP=0000H,CPU从内存FFFF0H(第一条指令)单元中读取指令执行。
在内存中 指令和数据 是没有任何区别的，都是二进制数据。CPU只有在工作的时候才将有的信息当作指令，有的信息当作数据.

指令的执行过程
1、CPU从CS:IP 所指的内存单元读取数据，存放到指令缓冲器
2、IP = IP+所读指令的长度，从而得到下一条指令的位置
3、执行指令缓存器中的内容，回到第一步

mov 是传送指令
jmp 是转移指令 ，jmp 段地址:偏移地址 可以改变 CS:IP 的值, jmp + 寄存器 = 只修改 IP 的值

setNumber:
			jmp setNumber   ; 跳转到setNumber代码段的内存地址，即将IP寄存器中的值修改为setNumber标识的内存地址，类似 C 中的 goto

ds 段地址寄存器 访问数据用的,8086CPU自动取ds中的数据为内存单元的段地址，不支持直接将数据写入寄存器的操作，需要先将数据写入bx寄存器在写入ds中
mov bx,1000H
mov bs,bx
mov al,ds:[0] mov 移动指令， 将数据写入CPU中的al寄存器，ds为段地址，[0] 为偏移地址，读取一个字节的数据，因为 al 为 8位寄存器
mov ax,ds:[0] 一个字型数据 ax是16位寄存器

寄存器,段地址:偏移地址     物理地址   内存中的内容  
mov ax,1000H                
mov ds,ax                   
mov ax,ds:[0]               10000H      23H        ;[0]=1123H ax=1123H
mov bx,ds:[2]               10001H      11H        ;[1]=2211H cx=2211H
mov cx,ds:[1]               10002H      22H        ;[2]=6622H bx=6622H
add bx,ds:[1]                                      bx=8833H
add cx,ds:[2]                                      cx=8833H
mov bx,10H
mov al,ds[bx]   偏移地址寄存器
add bx,1
mov al,ds[bx]

3、栈
push 入栈，将16位寄存器或者内存中的 字型数据 放到栈顶标记的上面，修改栈顶标记
pop  出栈，将栈顶标记的 字型数据 放到 16位寄存器或者内存中，修改栈顶标记

栈顶标记是内存地址， 段地址和偏移地址来表示
在 8086CPU中 在任意时刻将段地址寄存器SS 和 偏移地址寄存器SP 所组合出来的内存地址作为栈顶标记
push ax 修改SP寄存器中的值 SP=SP-2，将 AX 中的字数据 放到 SS:SP 所组合出来的内存地址中去
pop bx  SS:SP 所组合出来的内存地址中的 字数据 ->BX, 修改SP寄存器中的值 SP=SP+2
16byte=8字型数据，可以进行8次操作，0000(起始地址)+10H(栈大小)
栈是有上限和下限的，栈的大小根据数据的多少去安排
SP寄存器的变化范围  0~FFFFH 65536byte=32768字型数据
SS=2000H SP=0 就是设置栈最大的空间，push 操作 SP-2=0000-0002=FFFEH，当push到32768个数据是 SP=0，在进行 push 就会覆盖原来栈中的数据
栈的作用：
    1、临时性保存数据
    2、交换数据

内存段的安全 数据段、代码(指令)段、栈段
mov指令，可以修改系统存放在内存中的重要数据或者指令导致程序崩溃，系统崩溃
(1) 向安全的内存空间写入内容，0:200 ~ 0:2FFH ，256个字节大小
(2) 使用操作系统分配给程序的内容空间，在操作系统的环境中，合法的通过操作系统获取的内存空间都是安全的，操作系统为程序分配内存的方式，一是系统加载程序时为程序分配内存空间，二是程序在执行过程中，向系统申请内存

4、程序
汇编程序源代码文件 asm
汇编语言
 (1) 汇编指令  mov add sub push 被汇编器翻译成 0101 机器指令，机器码由CPU执行
 (2) 伪指令    由汇编器执行  start 、 end 、 code segment
 (3) 符号体系  由汇编器执行  + - * /

汇编后的可执行程序里面会向系统申请一段内存，同时包含一些描述信息，系统根据这些描述系统对 寄存器 进行相关的设置

start 伪指令告诉汇编器，将我们设置的程序入口地址告诉可执行文件
code segment 告诉汇编器 指令段开始位置
code ends    告诉汇编器 指令段结束位置
data segment 告诉汇编器 data段开始位置
data ends    告诉汇编器 data段结束位置   为了分配内存

mov ax,4c00H;  int 21H; 来实现程序返回的功能
操作系统的shell程序加载可执行程序并给程序分配内存，设置CPU的CS:IP寄存器，在程序返回时将内存和寄存器返还给系统
程序的跟踪 debug + 程序名
cx = 程序的长度
p 执行 int 指令
g + IP寄存器中的值，直接执行到该内存地址的指令出
q 退出
PSP区 从 ds:0 开始的 256 个字节，其中包含程序的名称，系统加载程序到内存中，用来系统和程序进行通讯

inc 指令是将寄存器中的值自增1 = add bx,1，不过 inc 指令只占一个字节， add bx,1 占3个字节，节约内存

loop 指令，循环指令 ，循环次数保存在 cx 寄存器中，每执行一次修改 cx 中的值减 1
loop 指令的 2 个步骤
 (1) cx = cx - 1
 (2) 判断 cx 中的值，不为 0 则跳转(jmp)到标识(setNumber内存地址)位置继续执行，等于 0 则执行下面的命令

			mov cx,16  ;执行 16 次循环
setNumber:
			loop setNumber 